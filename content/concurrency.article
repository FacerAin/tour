동시성
Go는 동시성 구조를 언어의 핵심의 일부분으로서 제공합니다. 이번 강의에서 그러한 구조들과 그것들이 어떻게 사용되는 지에 대한 예시를 보여드리겠습니다.

The Go Authors
https://golang.org

* Goroutines

_goroutine_은 Go 런타임에 의해 관리되는 경량 쓰레드입니다.

	go f(x, y, z)

새로운 goroutine을시작합니다.

	f(x, y, z)

f와 x, y, z의 evaluation은 현재의 goroutine에서 일어나고, `f`의 실행은 새로운 goroutine에서 일어납니다.

goroutine은 같은 주소의 공간에서 실행되고, 따라서 공유된 메모리는 synchronous 해야합니다.
Go에 다른 기본형들이 존재하고 당신이 Go에서 sync와 관련한 기본형이 필요없다하더라도[[https://golang.org/pkg/sync/][`sync`]] 패키지는 유용한 기본형을 제공합니다.
(다음 페이지에서 자세히 확인해보십시오.)
goroutine은 같은 주소 공간에서 실행되고 따라서 공유된 메모리에 대한 접근은 synchronous 해야만합니다.


.play concurrency/goroutines.go

* Channel

Channel은 당신이 채널 연산자인 `<-` 을 통해 값을 주고 받을 수 있는 하나의 분리된 통로입니다.
Channel are a typed conduit through which you can send and receive values with the channel operator, `<-`.

	ch <- v    // 채널 ch에 v를 전송한다.
	v := <-ch  // ch로 부터 값을 받고,
	           // 값을 v에 대입한다.

(데이터는 화살표의 방향대로 흐릅니다.)

map과 slice처럼 channel은 사용하기 전에 생성되어야만합니다.:

	ch := make(chan int)

기본적으로 전송과 수신은 다른 한 쪽이 준비될 때까지 block 상태입니다. 이는 명시적인 lock이나 조건 변수 없이 goroutine이 synchronous하게 작업될 수 있도록 합니다.

예제 코드는 두 개의 goroutine에 작업을 분산시키면서 슬라이스에 있는 숫자들을 더합니다.
두 goroutine이 그들의 연산을 완료하면, 최종 결과를 계산합니다.

.play concurrency/channels.go

* Buffered Channels

Channel은 _buffered_ 될 수 있습니다. buffered channel을 초기화하기 위해 `make` 에 두 번째 인자로 buffer 길이를 제공하십시오.

	ch := make(chan int, 100)

buffered channel 로의 전송은 그 buffer의 사이즈가 꽉 찼을 때에만 차단됩니다. buffer로 부터의 수신은 그 buffer가 비어있을 때 차단됩니다.

buffer가 초과하도록 예제를 수정해보고 어떤 일이 발생하는 지 확인해보십시오.

.play concurrency/buffered-channels.go

* Range and Close

A sender can `close` a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after

	v, ok := <-ch

`ok` is `false` if there are no more values to receive and the channel is closed.

The loop `for`i`:=`range`c` receives values from the channel repeatedly until it is closed.

*Note:* Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.

*Another*note:* Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a `range` loop.

.play concurrency/range-and-close.go

* Select

The `select` statement lets a goroutine wait on multiple communication operations.

A `select` blocks until one of its cases can run, then it executes that case.  It chooses one at random if multiple are ready.

.play concurrency/select.go

* Default Selection

The `default` case in a `select` is run if no other case is ready.

Use a `default` case to try a send or receive without blocking:

	select {
	case i := <-c:
		// use i
	default:
		// receiving from c would block
	}

.play concurrency/default-selection.go

* Exercise: Equivalent Binary Trees

There can be many different binary trees with the same sequence of values stored in it. For example, here are two binary trees storing the sequence 1, 1, 2, 3, 5, 8, 13.

.image /content/img/tree.png

A function to check whether two binary trees store the same sequence is quite complex in most languages. We'll use Go's concurrency and channels to write a simple solution.

This example uses the `tree` package, which defines the type:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Continue description on [[javascript:click('.next-page')][next page]].

* Exercise: Equivalent Binary Trees

*1.* Implement the `Walk` function.

*2.* Test the `Walk` function.

The function `tree.New(k)` constructs a randomly-structured (but always sorted) binary tree holding the values `k`, `2k`, `3k`, ..., `10k`.

Create a new channel `ch` and kick off the walker:

	go Walk(tree.New(1), ch)

Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.

*3.* Implement the `Same` function using `Walk` to determine whether `t1` and `t2` store the same values.

*4.* Test the `Same` function.

`Same(tree.New(1),`tree.New(1))` should return true, and `Same(tree.New(1),`tree.New(2))` should return false.

The documentation for `Tree` can be found [[https://godoc.org/golang.org/x/tour/tree#Tree][here]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

We've seen how channels are great for communication among goroutines.

But what if we don't need communication? What if we just want to make sure only
one goroutine can access a variable at a time to avoid conflicts?

This concept is called _mutual_exclusion_, and the conventional name for the data structure that provides it is _mutex_.

Go's standard library provides mutual exclusion with
[[https://golang.org/pkg/sync/#Mutex][`sync.Mutex`]] and its two methods:

- `Lock`
- `Unlock`

We can define a block of code to be executed in mutual exclusion by surrounding it
with a call to `Lock` and `Unlock` as shown on the `Inc` method.

We can also use `defer` to ensure the mutex will be unlocked as in the `Value` method.

.play concurrency/mutex-counter.go

* Exercise: Web Crawler

In this exercise you'll use Go's concurrency features to parallelize a web crawler.

Modify the `Crawl` function to fetch URLs in parallel without fetching the same URL twice.

_Hint_: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not
safe for concurrent use!

.play concurrency/exercise-web-crawler.go

* Where to Go from here...

#appengine: You can get started by
#appengine: [[https://golang.org/dl/][installing Go]].

#appengine: Once you have Go installed, the
The
[[https://golang.org/doc/][Go Documentation]] is a great place to
#appengine: continue.
start.
It contains references, tutorials, videos, and more.

To learn how to organize and work with Go code, watch [[https://www.youtube.com/watch?v=XCsL89YtqCs][this screencast]] or read [[https://golang.org/doc/code.html][How to Write Go Code]].

If you need help with the standard library, see the [[https://golang.org/pkg/][package reference]]. For help with the language itself, you might be surprised to find the [[https://golang.org/ref/spec][Language Spec]] is quite readable.

To further explore Go's concurrency model, watch
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Go Concurrency Patterns]]
([[https://talks.golang.org/2012/concurrency.slide][slides]])
and
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Advanced Go Concurrency Patterns]]
([[https://talks.golang.org/2013/advconc.slide][slides]])
and read the
[[https://golang.org/doc/codewalk/sharemem/][Share Memory by Communicating]]
codewalk.

To get started writing web applications, watch
[[https://vimeo.com/53221558][A simple programming environment]]
([[https://talks.golang.org/2012/simple.slide][slides]])
and read the
[[https://golang.org/doc/articles/wiki/][Writing Web Applications]] tutorial.

The [[https://golang.org/doc/codewalk/functions/][First Class Functions in Go]] codewalk gives an interesting perspective on Go's function types.

The [[https://blog.golang.org/][Go Blog]] has a large archive of informative Go articles.

Visit [[https://golang.org][golang.org]] for more.

