Method와 interface
이 강의는 object와 그것들의 행동을 정의하는 구조인 method와 interface를 다룹니다.

The Go Authors
https://golang.org

* Methods

Go는 클래스를 가지지 않습니다.

하지만, 그와 같은 타입의 메소드를 정의할 수 있습니다.

그 메서드는 특별한 _receiver_ 인자가 있는 함수입니다.

그 receiver는 `func` 키워드와 메서드 이름 사이의 자체 인수 목록에 나타납니다.

(receiver는 이하 리시버라고 칭하겠습니다.)

이 예에서 `Abs` 메소드에는 `v` 라는 이름의 `Vertex` 유형의 리시버가 있습니다.

.play methods/methods.go

* Methods는 함수입니다.

기억할 것: 메소드는 리시버 인수가 있는 함수입니다.

다음은 기능 변경 없이 일반 함수로 작성된 `Abs`입니다.

.play methods/methods-funcs.go

* Methods 계속

구조체가 아닌 형식에 대해서도 메소드를 선언할 수 있습니다.

이 예에서는 `Abs` 메소드가 있는 숫자 유형 'MyFloat'을 확인할 수 있습니다.

메소드와 동일한 패키지에 유형이 정의된 수신자가 있는 메소드만 선언할 수 있습니다.

유형이 다른 패키지 (`int`와 같은 빌트인 유형 포함)에 정의된 리시버로 메소드를 선언 할 수 없습니다.

.play methods/methods-continued.go

* 포인터 리시버

포인터 리시버로 메소드를 선언 할 수 있습니다.

이는 리시버 유형이 일부 유형 `T`에 대한 리터럴 구문 ``*T`를 가짐을 의미합니다.
(또한 `T` 자체는`* int`와 같은 포인터가 될 수 없습니다.)

예를 들어, 여기서 `Scale`방법은 `*Vertex`에 정의되어 있습니다.

포인터 리시버가 있는 메소드는 리시버가 가리키는 값을 수정할 수 있습니다 (`Scale`이 여기에서 하는 것처럼).

메소드는 종종 리시버를 수정해야하기에 포인터 리시버가 값 수신기보다 더 일반적입니다.

16 행의 `Scale` 함수 선언에서 `*`를 제거하고 프로그램의 동작이 어떻게 변하는 지 관찰해보십시오.

값 수신기를 사용하면 `Scale`메서드가 원래 `Vertex`값의 복사본에서 작동합니다.
(이것은 다른 함수 인수와 동일합니다.)

`Scale`메소드에는 `main`함수에 선언된 `Vertex`값을 변경하기 위한 포인터 리시버가 있어야합니다.

.play methods/methods-pointers.go

* 포인터와 함수

여기서 우리는 함수로 재 작성된 `Abs`와 `Scale` 메소드를 볼 수 있습니다.

다시 16 행에서 `*` 를 제거해보십시오.

동작이 바뀌는 것을 볼 수 있습니까?

예제를 컴파일하기 위해서는 무엇을 변경해야합니까?

(확실하지 않은 경우 다음 페이지로 이동하십시오.)

.play methods/methods-pointers-explained.go

* 메소드와 포인터 indirection

이전 두 프로그램을 비교하여 포인터 인수의 함수가 다음과 같은 포인터를 사용해야함을 알 수 있다.

	var v Vertex
	ScaleFunc(v, 5)  // Compile error!
	ScaleFunc(&v, 5) // OK

포인터 리시버가 있는 메소드는 다음과 같이 호출될 때 값이나 포인터를 리시버로 받아들인다.

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

`v`라는 문장의 경우, `v.Scale(5)`는 `v`가 포인터가 아니라 값인데도 포인터 리시버가 있는 메서드는 자동으로 호출된다.

즉, `Scale` 메서드가 포인터 리시버를 가졌기 때문에 편의상 Go는 `v.Scale(5)`라는 것을 `(&v).Scale(5)`로 해석한다.

.play methods/indirection.go

* 메소드와 포인터 indirection (2)

이와 동등한 일은 역방향에서 일어날 수 있다.

값 인수를 사용하는 함수는 다음과 같은 특정 유형의 값을 사용해야 한다.

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Compile error!

value receiver 가 있는 메서드는 다음과 같이 호출될 때, 값이나 포인터를 리시버로 사용한다.

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

이 경우에, `p.Abs()`라는 메서드는 `(*p).Abs()`로 해석된다.

.play methods/indirection-values.go

* 값 또는 포인터 리시버 선택

포인터 리시버를 사용하는 데에는 두 가지 이유가 있다.

첫번째는, 메서드가 리시버가 가리키는 값을 수정할 수 있기 때문이다.

두번째는 각각의 메서드 call에서의 value 복사 문제를 피하기 위해서이다.

예를 들어 리시버가 큰 구조체라면 이것은 더 효율적일 수 있다.

이 예시에서, `Abs`메서드는 리시버 방식을 수정할 필요가 없지만 `Scale`과 `Abs`는 모두 `*Vertex`라는 리시버 타입으로 되어있다.

일반적으로 특정 유형의 모든 방법에는 값이나 포인터 리시버가 있어야 하지만 둘 다 혼합되어서는 안된다.
(몇 페이지에 걸쳐 그 이유를 알아보자.)

.play methods/methods-with-pointer-receivers.go

* Interfaces

_interface_type_은 메소드의 시그니처 집합으로 정의됩니다.

인터페이스 유형의 값은 해당 메소드를 구현하는 모든 값을 보유 할 수 있습니다.

*참고:* 예제 코드 22행에 오류가 있습니다.
`Vertex`(값 유형)는 `Abser`를 구현하지 않습니다.
왜냐하면 `Abs`메소드는 `*Vertex`(포인터 유형)에서만 정의되기 때문입니다.

.play methods/interfaces.go

* 인터페이스의 암시적 구현.

type implements는 메소드를 실행함으로써 인터페이스를 구현합니다.
명시적 intent의 선언도, "implementation"의 키워드도 없습니다.

암시적 인터페이스는 인터페이스의 정의를 구현으로부터 분리하며,
이는 사전 정렬 없이 어떠한 패키지에 등장할 수 있습니다.

.play methods/interfaces-are-satisfied-implicitly.go

* 인터페이스 값

hood 아래에서, 인터페이스의 값은 값과 콘크리트 타입의 튜플이라고 생각할 수 있습니다.

	(value, type)

인터페이스 값은 특정 기초 콘크리트 유형의 가치를 가집니다.

인터페이스 값으로 메소드를 호출하면 기본 형식에 동일한 이름의 메서드가 실행됩니다.

.play methods/interface-values.go

* Nill 인터페이스 값

인터페이스 자체 내부의 콘크리트 값이 0일 경우, 그 메소드는 nil 리시버로 호출됩니다.

일부 언어에서는 이것이 null 포인터 예외를 발생시키지만,
Go 에서는 nil 리시버로 호출되는 것으로 불리는 매우 좋은 방법을 사용하는 것이 일반적입니다.
(이 예시의 `M`이라는 방법과 같습니다.)

nil 콘크리트 값을 갖는 인터페이스 값 자체가 nil이 아니라는 점에 유의해야 합니다.

.play methods/interface-values-with-nil.go

* Nil 인터페이스 값

Nil 인터페이스 값은 값 또는 콘크리트 유형 모두를 가지지 않습니다.

nil 인터페이스에서 메소드를 호출하는 것은 런타임 에러입니다.
왜냐하면, 어떠한 _구체적인_ 메소드를 호출할지를 나타내는 인터페이스 튜플 내부의 타입이 없기 때문입니다.

.play methods/nil-interface-values.go

* 빈 인터페이스 값

0 메서드를 지칭하는 인터페이스 유형을 _empty_interface_라고 합니다:

	interface{}

빈 인터페이스는 모든 유형의 값을 가질 수 있습니다.
(모든 유형은 최소 0개의 메소드를 구현합니다.)

빈 인터페이스는 알 수 없는 값을 처리하는데 이용됩니다.
예를 들어, `fmt.Print`는 `interface{}` 타입의 어떠한 인수라도 취할 수 있습니다.

.play methods/empty-interface.go

* 타입 선언

_type_assertion_은 인터페이스 값의 기초적인 콘크리트 값에 대한 접근을 제공합니다.

	t := i.(T)

이는 인터페이스 값 `i`가 콘크리트 타입 `T`를 갖고 있으며,
그 기본 값인 `T` 값을 변수 `t`에 할당하고 있다고 선언합니다.

만약 `i`가 `T`를 갖지 못하면면 그 선언은 panic이 됩니다.

인터페이스 값이 특정 유형을 보유하는지 여부를 _test_하기 위해,
타입 선언에서는 두 가지 값, 즉 기본 값과 선언 성공 여부를 보고하는 부울 값을 반환할 수 있습니다.

	t, ok := i.(T)

만약 `i`가 `T`를 갖고 있다면, `t`는 underlying value가 되며, `ok`가 true를 반환합니다.

만약 그렇지 않다면, `ok`는 거짓이 되고 `t`는 `T`라는 유형의 zero 값이 되며 어떠한 패닉도 발생하지 않습니다.

이 구문과 map에서 읽는 구문 간의 유사성에 유의하십시오.

.play methods/type-assertions.go

* 타입 스위치

_type_switch는 여러 타입의 선언을 직렬로 허용하는 구조입니다.

타입 스위치는 일반 스위치문과 같지만 타입 스위치문의 경우에는 값이 아닌 타입을 명시하며,
그 값들은 지정된 인터페이스 값에 의해 유지되는 값의 타입과 비교됩니다.

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

타입 스위치의 선언은 타입 선언 `i.(T)`와 같은 구문을 가집니다.
그러나 특정 타입인 `T`는 `type`이라는 키워드로 대체됩니다.

이 스위치 문장은 인터페이스 값 `i`가 `T`형인지 `S`형인지 시험합니다.
`T`와 `S`의 각각의 경우 변수 `v`는 각각 `T`형과 `S`형으로, `i`형이 보유한 값을 보유하게 됩니다.
디폴트 케이스(일치하지 않는 경우)에서 변수 `v`는 인터페이스 종류와 값이 `i`와 같습니다.

.play methods/type-switches.go

* Stringers

One of the most ubiquitous interfaces is [[//golang.org/pkg/fmt/#Stringer][`Stringer`]] defined by the [[//golang.org/pkg/fmt/][`fmt`]] package.

	type Stringer interface {
		String() string
	}

A `Stringer` is a type that can describe itself as a string. The `fmt` package
(and many others) look for this interface to print values.

.play methods/stringer.go

* Exercise: Stringers

Make the `IPAddr` type implement `fmt.Stringer` to print the address as
a dotted quad.

For instance, `IPAddr{1,`2,`3,`4}` should print as `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Errors

Go programs express error state with `error` values.

The `error` type is a built-in interface similar to `fmt.Stringer`:

	type error interface {
		Error() string
	}

(As with `fmt.Stringer`, the `fmt` package looks for the `error` interface when
printing values.)

Functions often return an `error` value, and calling code should handle errors
by testing whether the error equals `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

A nil `error` denotes success; a non-nil `error` denotes failure.

.play methods/errors.go

* Exercise: Errors

Copy your `Sqrt` function from the [[/flowcontrol/8][earlier exercise]] and modify it to return an `error` value.

`Sqrt` should return a non-nil error value when given a negative number, as it doesn't support complex numbers.

Create a new type

	type ErrNegativeSqrt float64

and make it an `error` by giving it a

	func (e ErrNegativeSqrt) Error() string

method such that `ErrNegativeSqrt(-2).Error()` returns `"cannot`Sqrt`negative`number:`-2"`.

*Note:* A call to `fmt.Sprint(e)` inside the `Error` method will send the program into an infinite loop. You can avoid this by converting `e` first: `fmt.Sprint(float64(e))`. Why?

Change your `Sqrt` function to return an `ErrNegativeSqrt` value when given a negative number.

.play methods/exercise-errors.go

* Readers

The `io` package specifies the `io.Reader` interface,
which represents the read end of a stream of data.

The Go standard library contains [[https://golang.org/search?q=Read#Global][many implementations]] of this interface, including files, network connections, compressors, ciphers, and others.

The `io.Reader` interface has a `Read` method:

	func (T) Read(b []byte) (n int, err error)

`Read` populates the given byte slice with data and returns the number of bytes
populated and an error value. It returns an `io.EOF` error when the stream
ends.

The example code creates a
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
and consumes its output 8 bytes at a time.

.play methods/reader.go

* Exercise: Readers

Implement a `Reader` type that emits an infinite stream of the ASCII character
`'A'`.

.play methods/exercise-reader.go

* Exercise: rot13Reader

A common pattern is an [[https://golang.org/pkg/io/#Reader][io.Reader]] that wraps another `io.Reader`, modifying the stream in some way.

For example, the [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] function takes an `io.Reader` (a stream of compressed data) and returns a `*gzip.Reader` that also implements `io.Reader` (a stream of the decompressed data).

Implement a `rot13Reader` that implements `io.Reader` and reads from an `io.Reader`, modifying the stream by applying the [[https://en.wikipedia.org/wiki/ROT13][rot13]] substitution cipher to all alphabetical characters.

The `rot13Reader` type is provided for you.
Make it an `io.Reader` by implementing its `Read` method.

.play methods/exercise-rot-reader.go

* Images

[[https://golang.org/pkg/image/#Image][Package image]] defines the `Image` interface:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Note*: the `Rectangle` return value of the `Bounds` method is actually an
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], as the
declaration is inside package `image`.

(See [[https://golang.org/pkg/image/#Image][the documentation]] for all the details.)

The `color.Color` and `color.Model` types are also interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`. These interfaces and types are specified by the [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

* Exercise: Images

Remember the [[/moretypes/18][picture generator]] you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

Define your own `Image` type, implement [[https://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

`Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

`ColorModel` should return `color.RGBAModel`.

`At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play methods/exercise-images.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
