Method와 interface
이 강의는 object와 그것들의 행동을 정의하는 구조인 method와 interface를 다룹니다.

The Go Authors
https://golang.org

* Methods

Go는 클래스를 가지지 않습니다.

하지만, 그와 같은 타입의 메소드를 정의할 수 있습니다.

그 메서드는 특별한 _receiver_ 인자가 있는 함수입니다.

그 receiver는 `func` 키워드와 메서드 이름 사이의 자체 인수 목록에 나타납니다.

(receiver는 이하 리시버라고 칭하겠습니다.)

이 예에서 `Abs` 메소드에는 `v` 라는 이름의 `Vertex` 유형의 리시버가 있습니다.

.play methods/methods.go

* Methods는 함수입니다.

기억할 것: 메소드는 리시버 인수가 있는 함수입니다.

다음은 기능 변경 없이 일반 함수로 작성된 `Abs`입니다.

.play methods/methods-funcs.go

* Methods 계속

구조체가 아닌 형식에 대해서도 메소드를 선언할 수 있습니다.

이 예에서는 `Abs` 메소드가 있는 숫자 유형 'MyFloat'을 확인할 수 있습니다.

메소드와 동일한 패키지에 유형이 정의된 수신자가 있는 메소드만 선언할 수 있습니다.

유형이 다른 패키지 (`int`와 같은 빌트인 유형 포함)에 정의된 리시버로 메소드를 선언 할 수 없습니다.

.play methods/methods-continued.go

* 포인터 리시버

포인터 리시버로 메소드를 선언 할 수 있습니다.

이는 리시버 유형이 일부 유형 `T`에 대한 리터럴 구문 ``*T`를 가짐을 의미합니다.
(또한 `T` 자체는`* int`와 같은 포인터가 될 수 없습니다.)

예를 들어, 여기서 `Scale`방법은 `*Vertex`에 정의되어 있습니다.

포인터 리시버가 있는 메소드는 리시버가 가리키는 값을 수정할 수 있습니다 (`Scale`이 여기에서 하는 것처럼).

메소드는 종종 리시버를 수정해야하기에 포인터 리시버가 값 수신기보다 더 일반적입니다.

16 행의 `Scale` 함수 선언에서 `*`를 제거하고 프로그램의 동작이 어떻게 변하는 지 관찰해보십시오.

값 수신기를 사용하면 `Scale`메서드가 원래 `Vertex`값의 복사본에서 작동합니다.
(이것은 다른 함수 인수와 동일합니다.)

`Scale`메소드에는 `main`함수에 선언된 `Vertex`값을 변경하기 위한 포인터 리시버가 있어야합니다.

.play methods/methods-pointers.go

* 포인터와 함수

여기서 우리는 함수로 재 작성된 `Abs`와 `Scale` 메소드를 볼 수 있습니다.

다시 16 행에서 `*` 를 제거해보십시오.

동작이 바뀌는 것을 볼 수 있습니까?

예제를 컴파일하기 위해서는 무엇을 변경해야합니까?

(확실하지 않은 경우 다음 페이지로 이동하십시오.)

.play methods/methods-pointers-explained.go

* 메소드와 포인터 indirection

이전 두 프로그램을 비교하여 포인터 인수의 함수가 다음과 같은 포인터를 사용해야함을 알 수 있다.

	var v Vertex
	ScaleFunc(v, 5)  // Compile error!
	ScaleFunc(&v, 5) // OK

포인터 리시버가 있는 메소드는 다음과 같이 호출될 때 값이나 포인터를 리시버로 받아들인다.

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

`v`라는 문장의 경우, `v.Scale(5)`는 `v`가 포인터가 아니라 값인데도 포인터 리시버가 있는 메서드는 자동으로 호출된다.

즉, `Scale` 메서드가 포인터 리시버를 가졌기 때문에 편의상 Go는 `v.Scale(5)`라는 것을 `(&v).Scale(5)`로 해석한다.

.play methods/indirection.go

* 메소드와 포인터 indirection (2)

이와 동등한 일은 역방향에서 일어날 수 있다.

값 인수를 사용하는 함수는 다음과 같은 특정 유형의 값을 사용해야 한다.

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Compile error!

value receiver 가 있는 메서드는 다음과 같이 호출될 때, 값이나 포인터를 리시버로 사용한다.

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

이 경우에, `p.Abs()`라는 메서드는 `(*p).Abs()`로 해석된다.

.play methods/indirection-values.go

* 값 또는 포인터 리시버 선택

포인터 리시버를 사용하는 데에는 두 가지 이유가 있다.

첫번째는, 메서드가 리시버가 가리키는 값을 수정할 수 있기 때문이다.

두번째는 각각의 메서드 call에서의 value 복사 문제를 피하기 위해서이다.

예를 들어 리시버가 큰 구조체라면 이것은 더 효율적일 수 있다.

이 예시에서, `Abs`메서드는 리시버 방식을 수정할 필요가 없지만 `Scale`과 `Abs`는 모두 `*Vertex`라는 리시버 타입으로 되어있다.

일반적으로 특정 유형의 모든 방법에는 값이나 포인터 리시버가 있어야 하지만 둘 다 혼합되어서는 안된다.
(몇 페이지에 걸쳐 그 이유를 알아보자.)

.play methods/methods-with-pointer-receivers.go

* Interfaces

An _interface_type_ is defined as a set of method signatures.

A value of interface type can hold any value that implements those methods.

*Note:* There is an error in the example code on line 22.
`Vertex` (the value type) doesn't implement `Abser` because
the `Abs` method is defined only on `*Vertex` (the pointer type).

.play methods/interfaces.go

* Interfaces are implemented implicitly

A type implements an interface by implementing its methods.
There is no explicit declaration of intent, no "implements" keyword.

Implicit interfaces decouple the definition of an interface from its
implementation, which could then appear in any package without prearrangement.

.play methods/interfaces-are-satisfied-implicitly.go

* Interface values

Under the hood, interface values can be thought of as a tuple of a value and a
concrete type:

	(value, type)

An interface value holds a value of a specific underlying concrete type.

Calling a method on an interface value executes the method of the same name on
its underlying type.

.play methods/interface-values.go

* Interface values with nil underlying values

If the concrete value inside the interface itself is nil,
the method will be called with a nil receiver.

In some languages this would trigger a null pointer exception,
but in Go it is common to write methods that gracefully handle being called
with a nil receiver (as with the method `M` in this example.)

Note that an interface value that holds a nil concrete value is itself non-nil.

.play methods/interface-values-with-nil.go

* Nil interface values

A nil interface value holds neither value nor concrete type.

Calling a method on a nil interface is a run-time error because there is no
type inside the interface tuple to indicate which _concrete_ method to call.

.play methods/nil-interface-values.go

* The empty interface

The interface type that specifies zero methods is known as the _empty_interface_:

	interface{}

An empty interface may hold values of any type.
(Every type implements at least zero methods.)

Empty interfaces are used by code that handles values of unknown type.
For example, `fmt.Print` takes any number of arguments of type `interface{}`.

.play methods/empty-interface.go

* Type assertions

A _type_assertion_ provides access to an interface value's underlying concrete value.

	t := i.(T)

This statement asserts that the interface value `i` holds the concrete type `T`
and assigns the underlying `T` value to the variable `t`.

If `i` does not hold a `T`, the statement will trigger a panic.

To _test_ whether an interface value holds a specific type,
a type assertion can return two values: the underlying value
and a boolean value that reports whether the assertion succeeded.

	t, ok := i.(T)

If `i` holds a `T`, then `t` will be the underlying value and `ok` will be true.

If not, `ok` will be false and `t` will be the zero value of type `T`,
and no panic occurs.

Note the similarity between this syntax and that of reading from a map.

.play methods/type-assertions.go

* Type switches

A _type_switch_ is a construct that permits several type assertions in series.

A type switch is like a regular switch statement, but the cases in a type
switch specify types (not values), and those values are compared against
the type of the value held by the given interface value.

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

The declaration in a type switch has the same syntax as a type assertion `i.(T)`,
but the specific type `T` is replaced with the keyword `type`.

This switch statement tests whether the interface value `i`
holds a value of type `T` or `S`.
In each of the `T` and `S` cases, the variable `v` will be of type
`T` or `S` respectively and hold the value held by `i`.
In the default case (where there is no match), the variable `v` is
of the same interface type and value as `i`.

.play methods/type-switches.go

* Stringers

One of the most ubiquitous interfaces is [[//golang.org/pkg/fmt/#Stringer][`Stringer`]] defined by the [[//golang.org/pkg/fmt/][`fmt`]] package.

	type Stringer interface {
		String() string
	}

A `Stringer` is a type that can describe itself as a string. The `fmt` package
(and many others) look for this interface to print values.

.play methods/stringer.go

* Exercise: Stringers

Make the `IPAddr` type implement `fmt.Stringer` to print the address as
a dotted quad.

For instance, `IPAddr{1,`2,`3,`4}` should print as `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Errors

Go programs express error state with `error` values.

The `error` type is a built-in interface similar to `fmt.Stringer`:

	type error interface {
		Error() string
	}

(As with `fmt.Stringer`, the `fmt` package looks for the `error` interface when
printing values.)

Functions often return an `error` value, and calling code should handle errors
by testing whether the error equals `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

A nil `error` denotes success; a non-nil `error` denotes failure.

.play methods/errors.go

* Exercise: Errors

Copy your `Sqrt` function from the [[/flowcontrol/8][earlier exercise]] and modify it to return an `error` value.

`Sqrt` should return a non-nil error value when given a negative number, as it doesn't support complex numbers.

Create a new type

	type ErrNegativeSqrt float64

and make it an `error` by giving it a

	func (e ErrNegativeSqrt) Error() string

method such that `ErrNegativeSqrt(-2).Error()` returns `"cannot`Sqrt`negative`number:`-2"`.

*Note:* A call to `fmt.Sprint(e)` inside the `Error` method will send the program into an infinite loop. You can avoid this by converting `e` first: `fmt.Sprint(float64(e))`. Why?

Change your `Sqrt` function to return an `ErrNegativeSqrt` value when given a negative number.

.play methods/exercise-errors.go

* Readers

The `io` package specifies the `io.Reader` interface,
which represents the read end of a stream of data.

The Go standard library contains [[https://golang.org/search?q=Read#Global][many implementations]] of this interface, including files, network connections, compressors, ciphers, and others.

The `io.Reader` interface has a `Read` method:

	func (T) Read(b []byte) (n int, err error)

`Read` populates the given byte slice with data and returns the number of bytes
populated and an error value. It returns an `io.EOF` error when the stream
ends.

The example code creates a
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
and consumes its output 8 bytes at a time.

.play methods/reader.go

* Exercise: Readers

Implement a `Reader` type that emits an infinite stream of the ASCII character
`'A'`.

.play methods/exercise-reader.go

* Exercise: rot13Reader

A common pattern is an [[https://golang.org/pkg/io/#Reader][io.Reader]] that wraps another `io.Reader`, modifying the stream in some way.

For example, the [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] function takes an `io.Reader` (a stream of compressed data) and returns a `*gzip.Reader` that also implements `io.Reader` (a stream of the decompressed data).

Implement a `rot13Reader` that implements `io.Reader` and reads from an `io.Reader`, modifying the stream by applying the [[https://en.wikipedia.org/wiki/ROT13][rot13]] substitution cipher to all alphabetical characters.

The `rot13Reader` type is provided for you.
Make it an `io.Reader` by implementing its `Read` method.

.play methods/exercise-rot-reader.go

* Images

[[https://golang.org/pkg/image/#Image][Package image]] defines the `Image` interface:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Note*: the `Rectangle` return value of the `Bounds` method is actually an
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], as the
declaration is inside package `image`.

(See [[https://golang.org/pkg/image/#Image][the documentation]] for all the details.)

The `color.Color` and `color.Model` types are also interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`. These interfaces and types are specified by the [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

* Exercise: Images

Remember the [[/moretypes/18][picture generator]] you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

Define your own `Image` type, implement [[https://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

`Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

`ColorModel` should return `color.RGBAModel`.

`At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play methods/exercise-images.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
